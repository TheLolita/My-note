# 创服学习笔记

# 一.Java后端

## 1.Java语言

---

### ●Lambda表达式

[学习视频](https://www.bilibili.com/video/av62117143?from=search&seid=5915398398558028346)

#### 1.Lambda的本质和用途

![1580627430184](image/服创-学习笔记/1580627430184.png)

---



#### 2.Lanbda基本用法

![1580627620481](image/服创-学习笔记/1580627620481-1580702769946.png)



---



#### 3.Lambda精简用法

![1580627024634](image/服创-学习笔记/1580627024634-1580702774380.png)

---

#### 4.Lambda进阶用法

![1580628067875](image/服创-学习笔记/1580628067875-1580702781277.png)



![1580628428493](image/服创-学习笔记/1580628428493-1580702787261.png)

---



#### 5.系统内置的函数接口

![1580637442271](image/服创-学习笔记/1580637442271-1580702795246.png)

![1580638122621](image/服创-学习笔记/1580638122621-1580702800987.png)

![1580637309787](/image/服创-学习笔记/1580637309787.png)

![1580629934419](image/服创-学习笔记/1580629934419-1580702815993.png)



---

### ●Stream流

#### 1.Stream流  

[戳](https://blog.csdn.net/weixin_38361347/article/details/90247695)

#### 2.补充：[skip()和limit()方法及组合使用](https://www.bbsmax.com/A/MyJx27o2dn/)



### ●小技巧

#### 1.重载的小技巧

```java
public RestData<T> error() {
        return this.error(null);
    }
//无参调用参数为null的单参
    public RestData<T> error(String info) {
        return error(info, null);
    }
//单参调用一个双参，将未用到的参数设为null
    public RestData<T> error(String info, T data) {
        if (info != null && !info.isEmpty()) {
            this.status = false;
            this.info = info;
            this.data = data;
            return this;
        } else {
            return error(FAIL_INFO, data);
        }
    }
```



## 2.Java web

---



## 3.Spring

### ●spring 注解验证@NotNull等使用方法

[[戳]](https://blog.csdn.net/qq920447939/article/details/80198438)

---



## 4.Spring Boot

---



### ● 单元测试

[例子](https://blog.csdn.net/wo541075754/article/details/88983708)    [方法](https://blog.csdn.net/blueheart20/article/details/88899908)

**Note:**使用路径参数和表单参数接受参数的方式不同 [戳](https://blog.csdn.net/wang_muhuo/article/details/84655577)

1.路径参数@PathVariable

2.表单参数@RequestParam

---

### ● 文件上传与下载



#### 1.示例

```java
@RestController
@PropertySource("classpath:application.properties")
@Slf4j
public class FileController {

    @Autowired
    public Constant constant;

    @RequestMapping("/upload")
    public String upload(@RequestParam("file") MultipartFile file) {


        //判断file是否为empty()
        if(file.isEmpty())return "Please select file at first";

        //获取原始名字
        String fileName=file.getOriginalFilename();

        //获取后缀
        String suffix=fileName.substring(fileName.indexOf("."));

        //文件保存路径
        String filePath= constant.getUpload_Folder();

        //生出文件新的保存名称,UUID是为了生成不同的文件名
        fileName=filePath+UUID.randomUUID()+fileName;

        //生成文件对象
        File dest=new File(fileName);

        //判断生成的路径是否存在，若不存在，则创建一个
        if(!dest.getParentFile().exists())dest.getParentFile().mkdirs();

        //将文件保存下来
        try
        {
          /*  将收到的文件传输到给定的目标文件。
            这可以在文件系统中移动文件，在文件系统中复制文件或将内存保存的内容保存到目标文件。如果目标文件已经存在，则将首先删除它。*/
          file.transferTo(dest);
          return "success";
        }
        catch (Exception e)
        {
            return "error";
        }

    }


    @RequestMapping("/download")
    public String download(HttpServletResponse response) {
        try {
            // 文件地址，真实环境是存放在数据库中的
            File file = new File("C:\\upload\\6ce651bf-5627-4759-b153-dd8357b52147机巧少女不会受伤1.jpg");

            // 创建输入流，传入文件对象
            FileInputStream fis = new FileInputStream(file);

            // 设置相关格式
            response.setContentType("application/force-download");

            //设置下载时文件默认的文件名
            String fileName="机巧少女不会受伤.jpg";

            // 设置下载后的文件名以及header
            //URLEncoder避免中文乱码
            response.addHeader("Content-disposition", "attachment;filename="+ URLEncoder.encode(fileName,"UTF-8"));

            //创建输出流
            OutputStream os = response.getOutputStream();

            // 常规操作
            byte[] buf = new byte[1024];
            int len = 0;
            while ((len = fis.read(buf)) != -1) {
                os.write(buf, 0, len);
            }
            os.close();
            fis.close();
            return "success";
        } catch (IOException e) {
            e.printStackTrace();
            return "error";
        }
    }

    //当请求localhost:8080的时候 默认跳转到index.html页面
    //视图解析器
    @RequestMapping("/")
    public ModelAndView index() {
        System.out.println("i am springboot");
        return new ModelAndView("index");
    }
}

```

---

#### [2.下载时文件名中文乱码问题](https://blog.csdn.net/erf_1012/article/details/101026526)

---



### ● 重要注解

#### 1.@EnableAutoConfiguration注解 

[戳](https://blog.csdn.net/zxc123e/article/details/80222967)

###  ● LomBok

[官方文档](https://projectlombok.org/features/all)

```xml
	    <!--Lombok-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.16.20</version>
            <scope>provided</scope>
        </dependency>
```



1. **@Setter** 注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。

2.  **@Getter** 使用方法同上，区别在于生成的是getter方法。

3. **@ToString** 注解在类，添加toString方法。

   ​    <u>**Note**:默认在比较时不考虑父类的属性，若需要考虑加上@EqualsAndHashCode(callSuper=true)</u>

4. **@EqualsAndHashCode** 注解在类，生成hashCode和equals方法。

   ​	<u>**Note**:默认在比较时不考虑父类的属性，若需要考虑加上@EqualsAndHashCode(callSuper=true)</u>

5. **@NoArgsConstructor** 注解在类，生成无参的构造方法。

6. **@RequiredArgsConstructor** 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。

7. **@AllArgsConstructor** 注解在类，生成包含类中所有字段的构造方法。

8. **@Data** 注解在类，相当于`@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode`这5个注解的合集 

9. **@Log4j2**  **@Slf4j  @Commonslog  @...**：注解在类上；为类提供一个 属性名为log 的 log4j2、slf4j、commons-logging、...的日志对像 ，根据日志模块选择相应注解

10. **@Builder**注解在类、构造函数、方法上，

    1.生成一个全参的构造器，一个用于创建构建器的builder（）

    2.在构建器中会生成一个toString()方法和用于创建实体类的build()

    3.并在构建器中创建每一个非final(可赋值)的属性，并创建一个相应的，类似于set方法且返回构造器本身（便于链式调用）的方法

    ```java
    Person.builder() //创建一个构建器
        .name("Adam Savage")//调用name属性的类似set的方法，返回构造器本身
        .city("San Francisco")//因为Person.builder().name()仍然是构造器，可继续
        .job("Mythbusters")//链式调用
        .job("Unchained Reaction")//链式调用
        .build();//创建一个实体并用全参构造器赋值
    //Note:构造器中创建出来的属性值都为null
    //Note:若@Builder的同时加上@Default ,则构造器中创建出来的属性值可为默认的值
    ```

    参考[文献1](https://blog.csdn.net/weixin_41540822/article/details/86606562)，[文献2](https://segmentfault.com/a/1190000018962193)

    

    ---

    

### ● Yaml



---

### ● SpringBoot 小技巧

#### 1.让属性带上文字说明

![1580826372290](image/服创-学习笔记/1580826372290.png)

![1580826277225](image/服创-学习笔记/1580826277225.png)

---



## 5.Spring Cloud

## 6.Linux

### 1.命令

●.CentOS常用简单[命令](https://blog.csdn.net/qq_40087415/article/details/79367151)


## 7.其他

### 1.GitHub



### 2.Git

---

Git工作流程图

![1580696354106](image/服创-学习笔记/1580696354106-1580702830740.png)

先找一个地方创建自己的版本库

```java
$ mkdir My-note  ---在当前目录下创建一个 My-note文件夹 
$ cd My-note  --- 进入My-note文件夹-->里面的文件都是你的工作区（除了.git）
$ pwd  ---查看当前目录路径
/Users/michael/My-note
```

 

`$ git init`     把一个目录变成Git可管理的目录 增加一个.git文件（就是版本库） 若文件被隐藏可用ls -ah命令查看

`$ git status `查看信息 $ git log 查看commit日志 $ git relog 查看包括被回退的commit日志

`$ git log  --pretty=oneline` 将每一个日志简化为一行

`$ git diff` 文件  查看文件被修改的内容

`$ git add "文件名"`  将指定文件提交到暂存区  `$ git add . ` 将未提交文件提交到暂存区   

`$ git commit -m "提交说明"  `提交暂存区到远程仓库当前分支

`$ git checkout -- fileName `   是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 

`$ git reset HEAD  filename`   可以把暂存区（已add）的修改撤销掉（unstage），重新放回工作区 

`$ git reset --hard HEAD^  `回到上一个版本 HEAD^^上上个版本 HEAD~100上100个版本

`$ rm fileName ` 工作区删除文件

`$ git rm fileName `从暂存区删除掉file
`$ git commit -m "fileName" ` 重新提交  --上述两步使得文件从版本库中删除

在Github上创建一个repository My-note

`$ git remote add origin git@github.com:TheLolita/My-note.git`    使得本地仓库与远程仓库关联  （前提有SSH Key 才能推送操作）

由于远程库是空的，我们第一次推送`master`分支时，加上了`-u`参数，Git不但会把本地的`master`分支内容推送的远程新的`master`分支，还会把本地的`master`分支和远程的`master`分支关联起来，在以后的推送或者拉取时就可以简化命令。`$ git push -u origin master` 

此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改

`$ git branch` 命令会列出所有分支，当前分支前面会标一个`*`号。 

创建分支：`git branch XXX`   

切换分支：`git checkout `或者`git switch `

创建+切换分支：`git checkout -b `或者`git switch -c `

合并某分支到当前分支：`git merge `

删除分支：`git branch -d `

 `Fast-forward`信息，Git告诉我们，这次合并是“快进模式”，也就是直接把`master`指向`dev`的当前提交，所以合并速度非常快。 

 合并分支时，加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而`fast forward`合并就看不出来曾经做过合并。 

 用`git log --graph`命令可以看到分支合并图 


### 3.IDEA

---

#### ● 热部署

1.添加依赖

```xml
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-Devtools</artifactId>
<optional>true</optional>
</dependency>
```

2.在 plugin 中配置另外⼀一个属性 fork，并且配置为 true。

```xml
<build>
<plugins>
<plugin>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-maven-plugin</artifactId>
<configuration>
<fork>true</fork>
</configuration>
</plugin>
</plugins>
</build>
```

3.配置IDEA

![1580743203081](image/服创-学习笔记/1580743203081.png)![1580743231656](image/服创-学习笔记/1580743231656.png)

### 4.Maven

---



### 5.MyBatis

---



### 6.JPA

#### ● 什么是JPA?

<img src="image/服创-学习笔记/1580553234260-1580612451596.png" alt="1580553234260" style="zoom:80%;" />

JPA有多种实现：TopLink、OpenJpa、Hibernate

<img src="image/服创-学习笔记/1580553492462-1580612451596.png" alt="1580553492462" style="zoom:80%;" />



---

#### ● GeneratedValue的四种生成策略

![1580612559258](image/服创-学习笔记/1580612559258-1580702868580.png)

---

#### ● JPA常用注解

##### **@Enumerated**

@Enumerated(value=EnumType.ORDINAL)采用枚举类型的序号值与数据库进行交互 （默认）

@Enumerated(value=EnumType.STRING)采用枚举类型与数据库进行交互 

---



##### @MappedSuperclass

@MappedSuperclass 用于标识父类，生成子类的通用属性如Id、CreateTime、UpdateTime等

---



#### ●JPA公共Bean

![1580617052159](image/服创-学习笔记/1580617052159-1580702879129.png)

Desc 降序   Asc升序 

---





### 7.Spring MVC

### 8.Linux

### 9.Docker

### 10.Redis

### 11.MySQL

### 12.Druid

### 13.Others



# 二.Java前端

## 1.HTML

## 2.CSS

## 3.JavaScript

## 4.Thymeleaf



# 三.爬坑记录

## 1.遇见的错误及解决方法

## 2.小知识点与注意点

## 3.功能实现

#### ●  更换网页图标

1.用[IOC转换工具](http://www.bitbug.net)制作出自己喜欢的ioc图标，命名为favicon.ioc

2.将favicon.ioc放在静态资源目录下

```java
"classpath:/META-INF/resources/", 
"classpath:/resources/",
"classpath:/static/",
"classpath:/public/"

```

3.在application.properties/yaml配置文件中设置

```xml
spring.mvc.favicon.enabled=false
```

4.在每一个html页面的Head中加入Link（理论前3步即可完成配置）



```java
<link rel="icon" type="image/x-icon" th:href="@{/asserts/img/favicon.ico}">
 //我的favicon.ioc放在static/asserts/img目录下，注意此处使用相对路径 
```

5.若网页未成功显示新的图标，则清除浏览器缓存

---

#### ● 更换IDEA启动时的Banner

纯粹是为了好玩[手动滑稽]

![1580738299799](image/服创-学习笔记/1580738299799.png)

在[字符画工具](http://patorjk.com/software/taag/#p=display&h=0&v=3&f=3D%20Diagonal&t=ZSNB)制作出自己喜欢的Banner,保存为`banner.txt`放在resource目录下

![1580738264893](image/服创-学习笔记/1580738264893.png)

---



# 四.小工具

## 1.Typora

---

### ● Typora基本用法

[typora--官方文档](http://support.typora.io/Markdown-Reference/#headers)

[中文文档](https://www.w3cschool.cn/markdownyfsm/markdownyfsm-odm6256r.html)

[Typora--快捷键表](https://blog.csdn.net/HL4854/article/details/81279859)

![1580565286568](image/服创-学习笔记/1580565286568.png)

---

[查看更多快捷键](https://www.cnblogs.com/hongdada/p/9776547.html)

![1580566095497](image/服创-学习笔记/1580566095497.png)

![1580566073248](image/服创-学习笔记/1580566073248.png)

 行内代码 ：代码的两端各加一个“`”号，（在Tab键上面，英文输入法）。  

---

### ● 怎么用Typora和Git打造自己的云笔记？

[戳](https://blog.csdn.net/oPengXiaoLiang/article/details/100678908)

---

## 	2.[IOC转换工具](http://www.bitbug.net)

---

## 3. TortoiseSVN 

[1.安装 TortoiseSVN教程](https://jingyan.baidu.com/article/219f4bf78454d3de442d3885.html)

2.[TortoiseSVN下载地址](https://tortoisesvn.net/downloads.html)

3.[使用TortoiseSVN拉取版本](https://blog.csdn.net/weixin_38801572/article/details/87696732)

4.IDEA打开后提示：Can't use Subversion command line client: svn The path to the Subversion executable is probably wrong (Fix it)

点击Fix it 或进入 file->settings->Version Contorl->subversion->with command line client ，在TortoiseSVN安装目录下 找到一个svn.exe的文件，一路OK就行了 

---



## [4.VMware虚拟机](https://blog.csdn.net/java_xinshou1/article/details/100010099)



1.安装[VMWare Pro](https://www.cnblogs.com/elttwl/p/11083486.html)

2.先下载[CentOS7镜像](https://www.jianshu.com/p/a63f47e096e8)

3.[VMWare 安装CentOS](https://blog.csdn.net/java_xinshou1/article/details/100010099)







